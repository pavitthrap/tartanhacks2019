# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_speech_py_impl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_speech_py_impl')
    _speech_py_impl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_speech_py_impl', [dirname(__file__)])
        except ImportError:
            import _speech_py_impl
            return _speech_py_impl
        try:
            _mod = imp.load_module('_speech_py_impl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _speech_py_impl = swig_import_helper()
    del swig_import_helper
else:
    import _speech_py_impl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x



from typing import Optional

SHARED_PTR_DISOWN = _speech_py_impl.SHARED_PTR_DISOWN
class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self)                :
        return _speech_py_impl.SwigPyIterator_value(self)

    def incr(self, n          =1)                            :
        return _speech_py_impl.SwigPyIterator_incr(self, n)

    def decr(self, n          =1)                            :
        return _speech_py_impl.SwigPyIterator_decr(self, n)

    def distance(self, x                  )               :
        return _speech_py_impl.SwigPyIterator_distance(self, x)

    def equal(self, x                  )          :
        return _speech_py_impl.SwigPyIterator_equal(self, x)

    def copy(self)                            :
        return _speech_py_impl.SwigPyIterator_copy(self)

    def next(self)                :
        return _speech_py_impl.SwigPyIterator_next(self)

    def __next__(self)                :
        return _speech_py_impl.SwigPyIterator___next__(self)

    def previous(self)                :
        return _speech_py_impl.SwigPyIterator_previous(self)

    def advance(self, n             )                            :
        return _speech_py_impl.SwigPyIterator_advance(self, n)

    def __eq__(self, x                  )          :
        return _speech_py_impl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x                  )          :
        return _speech_py_impl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n             )                            :
        return _speech_py_impl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n             )                            :
        return _speech_py_impl.SwigPyIterator___isub__(self, n)

    def __add__(self, n             )                            :
        return _speech_py_impl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args)               :
        return _speech_py_impl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _speech_py_impl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self)                            :
        return _speech_py_impl.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)          :
        return _speech_py_impl.StringVector___nonzero__(self)

    def __bool__(self)          :
        return _speech_py_impl.StringVector___bool__(self)

    def __len__(self)                                           :
        return _speech_py_impl.StringVector___len__(self)

    def __getslice__(self, i                                               , j                                               )                                                                :
        return _speech_py_impl.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args)          :
        return _speech_py_impl.StringVector___setslice__(self, *args)

    def __delslice__(self, i                                               , j                                               )          :
        return _speech_py_impl.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args)          :
        return _speech_py_impl.StringVector___delitem__(self, *args)

    def __getitem__(self, *args)                                                    :
        return _speech_py_impl.StringVector___getitem__(self, *args)

    def __setitem__(self, *args)          :
        return _speech_py_impl.StringVector___setitem__(self, *args)

    def pop(self)                                            :
        return _speech_py_impl.StringVector_pop(self)

    def append(self, x                                                  )          :
        return _speech_py_impl.StringVector_append(self, x)

    def empty(self)          :
        return _speech_py_impl.StringVector_empty(self)

    def size(self)                                           :
        return _speech_py_impl.StringVector_size(self)

    def swap(self, v                )          :
        return _speech_py_impl.StringVector_swap(self, v)

    def begin(self)                                          :
        return _speech_py_impl.StringVector_begin(self)

    def end(self)                                          :
        return _speech_py_impl.StringVector_end(self)

    def rbegin(self)                                                  :
        return _speech_py_impl.StringVector_rbegin(self)

    def rend(self)                                                  :
        return _speech_py_impl.StringVector_rend(self)

    def clear(self)          :
        return _speech_py_impl.StringVector_clear(self)

    def get_allocator(self)                                                :
        return _speech_py_impl.StringVector_get_allocator(self)

    def pop_back(self)          :
        return _speech_py_impl.StringVector_pop_back(self)

    def erase(self, *args)                                          :
        return _speech_py_impl.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _speech_py_impl.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x                                                  )          :
        return _speech_py_impl.StringVector_push_back(self, x)

    def front(self)                                                    :
        return _speech_py_impl.StringVector_front(self)

    def back(self)                                                    :
        return _speech_py_impl.StringVector_back(self)

    def assign(self, n                                         , x                                                  )          :
        return _speech_py_impl.StringVector_assign(self, n, x)

    def resize(self, *args)          :
        return _speech_py_impl.StringVector_resize(self, *args)

    def insert(self, *args)          :
        return _speech_py_impl.StringVector_insert(self, *args)

    def reserve(self, n                                         )          :
        return _speech_py_impl.StringVector_reserve(self, n)

    def capacity(self)                                           :
        return _speech_py_impl.StringVector_capacity(self)
    __swig_destroy__ = _speech_py_impl.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _speech_py_impl.StringVector_swigregister
StringVector_swigregister(StringVector)

class StdMapStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StdMapStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StdMapStringString, name)
    __repr__ = _swig_repr

    def iterator(self)                            :
        return _speech_py_impl.StdMapStringString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)          :
        return _speech_py_impl.StdMapStringString___nonzero__(self)

    def __bool__(self)          :
        return _speech_py_impl.StdMapStringString___bool__(self)

    def __len__(self)                                                    :
        return _speech_py_impl.StdMapStringString___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key                                                         )                                                              :
        return _speech_py_impl.StdMapStringString___getitem__(self, key)

    def __delitem__(self, key                                                         )          :
        return _speech_py_impl.StdMapStringString___delitem__(self, key)

    def has_key(self, key                                                         )          :
        return _speech_py_impl.StdMapStringString_has_key(self, key)

    def keys(self)                :
        return _speech_py_impl.StdMapStringString_keys(self)

    def values(self)                :
        return _speech_py_impl.StdMapStringString_values(self)

    def items(self)                :
        return _speech_py_impl.StdMapStringString_items(self)

    def __contains__(self, key                                                         )          :
        return _speech_py_impl.StdMapStringString___contains__(self, key)

    def key_iterator(self)                            :
        return _speech_py_impl.StdMapStringString_key_iterator(self)

    def value_iterator(self)                            :
        return _speech_py_impl.StdMapStringString_value_iterator(self)

    def __setitem__(self, *args)          :
        return _speech_py_impl.StdMapStringString___setitem__(self, *args)

    def asdict(self)                :
        return _speech_py_impl.StdMapStringString_asdict(self)

    def __init__(self, *args):
        this = _speech_py_impl.new_StdMapStringString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self)          :
        return _speech_py_impl.StdMapStringString_empty(self)

    def size(self)                                                    :
        return _speech_py_impl.StdMapStringString_size(self)

    def swap(self, v                      )          :
        return _speech_py_impl.StdMapStringString_swap(self, v)

    def begin(self)                                                   :
        return _speech_py_impl.StdMapStringString_begin(self)

    def end(self)                                                   :
        return _speech_py_impl.StdMapStringString_end(self)

    def rbegin(self)                                                           :
        return _speech_py_impl.StdMapStringString_rbegin(self)

    def rend(self)                                                           :
        return _speech_py_impl.StdMapStringString_rend(self)

    def clear(self)          :
        return _speech_py_impl.StdMapStringString_clear(self)

    def get_allocator(self)                                                         :
        return _speech_py_impl.StdMapStringString_get_allocator(self)

    def count(self, x                                                         )                                                    :
        return _speech_py_impl.StdMapStringString_count(self, x)

    def erase(self, *args)          :
        return _speech_py_impl.StdMapStringString_erase(self, *args)

    def find(self, x                                                         )                                                   :
        return _speech_py_impl.StdMapStringString_find(self, x)

    def lower_bound(self, x                                                         )                                                   :
        return _speech_py_impl.StdMapStringString_lower_bound(self, x)

    def upper_bound(self, x                                                         )                                                   :
        return _speech_py_impl.StdMapStringString_upper_bound(self, x)
    __swig_destroy__ = _speech_py_impl.delete_StdMapStringString
    __del__ = lambda self: None
StdMapStringString_swigregister = _speech_py_impl.StdMapStringString_swigregister
StdMapStringString_swigregister(StdMapStringString)

class Uint8Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Uint8Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Uint8Vector, name)
    __repr__ = _swig_repr

    def iterator(self)                            :
        return _speech_py_impl.Uint8Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self)          :
        return _speech_py_impl.Uint8Vector___nonzero__(self)

    def __bool__(self)          :
        return _speech_py_impl.Uint8Vector___bool__(self)

    def __len__(self)                                             :
        return _speech_py_impl.Uint8Vector___len__(self)

    def __getslice__(self, i                                                 , j                                                 )                                                                    :
        return _speech_py_impl.Uint8Vector___getslice__(self, i, j)

    def __setslice__(self, *args)          :
        return _speech_py_impl.Uint8Vector___setslice__(self, *args)

    def __delslice__(self, i                                                 , j                                                 )          :
        return _speech_py_impl.Uint8Vector___delslice__(self, i, j)

    def __delitem__(self, *args)          :
        return _speech_py_impl.Uint8Vector___delitem__(self, *args)

    def __getitem__(self, *args)                                                      :
        return _speech_py_impl.Uint8Vector___getitem__(self, *args)

    def __setitem__(self, *args)          :
        return _speech_py_impl.Uint8Vector___setitem__(self, *args)

    def pop(self)                                              :
        return _speech_py_impl.Uint8Vector_pop(self)

    def append(self, x                                                    )          :
        return _speech_py_impl.Uint8Vector_append(self, x)

    def empty(self)          :
        return _speech_py_impl.Uint8Vector_empty(self)

    def size(self)                                             :
        return _speech_py_impl.Uint8Vector_size(self)

    def swap(self, v               )          :
        return _speech_py_impl.Uint8Vector_swap(self, v)

    def begin(self)                                            :
        return _speech_py_impl.Uint8Vector_begin(self)

    def end(self)                                            :
        return _speech_py_impl.Uint8Vector_end(self)

    def rbegin(self)                                                    :
        return _speech_py_impl.Uint8Vector_rbegin(self)

    def rend(self)                                                    :
        return _speech_py_impl.Uint8Vector_rend(self)

    def clear(self)          :
        return _speech_py_impl.Uint8Vector_clear(self)

    def get_allocator(self)                                                  :
        return _speech_py_impl.Uint8Vector_get_allocator(self)

    def pop_back(self)          :
        return _speech_py_impl.Uint8Vector_pop_back(self)

    def erase(self, *args)                                            :
        return _speech_py_impl.Uint8Vector_erase(self, *args)

    def __init__(self, *args):
        this = _speech_py_impl.new_Uint8Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x                                                    )          :
        return _speech_py_impl.Uint8Vector_push_back(self, x)

    def front(self)                                                      :
        return _speech_py_impl.Uint8Vector_front(self)

    def back(self)                                                      :
        return _speech_py_impl.Uint8Vector_back(self)

    def assign(self, n                                           , x                                                    )          :
        return _speech_py_impl.Uint8Vector_assign(self, n, x)

    def resize(self, *args)          :
        return _speech_py_impl.Uint8Vector_resize(self, *args)

    def insert(self, *args)          :
        return _speech_py_impl.Uint8Vector_insert(self, *args)

    def reserve(self, n                                           )          :
        return _speech_py_impl.Uint8Vector_reserve(self, n)

    def capacity(self)                                             :
        return _speech_py_impl.Uint8Vector_capacity(self)
    __swig_destroy__ = _speech_py_impl.delete_Uint8Vector
    __del__ = lambda self: None
Uint8Vector_swigregister = _speech_py_impl.Uint8Vector_swigregister
Uint8Vector_swigregister(Uint8Vector)

PropertyId_SpeechServiceConnection_Key = _speech_py_impl.PropertyId_SpeechServiceConnection_Key
PropertyId_SpeechServiceConnection_Endpoint = _speech_py_impl.PropertyId_SpeechServiceConnection_Endpoint
PropertyId_SpeechServiceConnection_Region = _speech_py_impl.PropertyId_SpeechServiceConnection_Region
PropertyId_SpeechServiceAuthorization_Token = _speech_py_impl.PropertyId_SpeechServiceAuthorization_Token
PropertyId_SpeechServiceAuthorization_Type = _speech_py_impl.PropertyId_SpeechServiceAuthorization_Type
PropertyId_SpeechServiceConnection_EndpointId = _speech_py_impl.PropertyId_SpeechServiceConnection_EndpointId
PropertyId_SpeechServiceConnection_ProxyHostName = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyHostName
PropertyId_SpeechServiceConnection_ProxyPort = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyPort
PropertyId_SpeechServiceConnection_ProxyUserName = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyUserName
PropertyId_SpeechServiceConnection_ProxyPassword = _speech_py_impl.PropertyId_SpeechServiceConnection_ProxyPassword
PropertyId_SpeechServiceConnection_TranslationToLanguages = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationToLanguages
PropertyId_SpeechServiceConnection_TranslationVoice = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationVoice
PropertyId_SpeechServiceConnection_TranslationFeatures = _speech_py_impl.PropertyId_SpeechServiceConnection_TranslationFeatures
PropertyId_SpeechServiceConnection_IntentRegion = _speech_py_impl.PropertyId_SpeechServiceConnection_IntentRegion
PropertyId_SpeechServiceConnection_RecoMode = _speech_py_impl.PropertyId_SpeechServiceConnection_RecoMode
PropertyId_SpeechServiceConnection_RecoLanguage = _speech_py_impl.PropertyId_SpeechServiceConnection_RecoLanguage
PropertyId_Speech_SessionId = _speech_py_impl.PropertyId_Speech_SessionId
PropertyId_SpeechServiceResponse_RequestDetailedResultTrueFalse = _speech_py_impl.PropertyId_SpeechServiceResponse_RequestDetailedResultTrueFalse
PropertyId_SpeechServiceResponse_RequestProfanityFilterTrueFalse = _speech_py_impl.PropertyId_SpeechServiceResponse_RequestProfanityFilterTrueFalse
PropertyId_SpeechServiceResponse_JsonResult = _speech_py_impl.PropertyId_SpeechServiceResponse_JsonResult
PropertyId_SpeechServiceResponse_JsonErrorDetails = _speech_py_impl.PropertyId_SpeechServiceResponse_JsonErrorDetails
PropertyId_CancellationDetails_Reason = _speech_py_impl.PropertyId_CancellationDetails_Reason
PropertyId_CancellationDetails_ReasonText = _speech_py_impl.PropertyId_CancellationDetails_ReasonText
PropertyId_CancellationDetails_ReasonDetailedText = _speech_py_impl.PropertyId_CancellationDetails_ReasonDetailedText
PropertyId_LanguageUnderstandingServiceResponse_JsonResult = _speech_py_impl.PropertyId_LanguageUnderstandingServiceResponse_JsonResult
OutputFormat_Simple = _speech_py_impl.OutputFormat_Simple
OutputFormat_Detailed = _speech_py_impl.OutputFormat_Detailed
ResultReason_NoMatch = _speech_py_impl.ResultReason_NoMatch
ResultReason_Canceled = _speech_py_impl.ResultReason_Canceled
ResultReason_RecognizingSpeech = _speech_py_impl.ResultReason_RecognizingSpeech
ResultReason_RecognizedSpeech = _speech_py_impl.ResultReason_RecognizedSpeech
ResultReason_RecognizingIntent = _speech_py_impl.ResultReason_RecognizingIntent
ResultReason_RecognizedIntent = _speech_py_impl.ResultReason_RecognizedIntent
ResultReason_TranslatingSpeech = _speech_py_impl.ResultReason_TranslatingSpeech
ResultReason_TranslatedSpeech = _speech_py_impl.ResultReason_TranslatedSpeech
ResultReason_SynthesizingAudio = _speech_py_impl.ResultReason_SynthesizingAudio
ResultReason_SynthesizingAudioCompleted = _speech_py_impl.ResultReason_SynthesizingAudioCompleted
CancellationReason_Error = _speech_py_impl.CancellationReason_Error
CancellationReason_EndOfStream = _speech_py_impl.CancellationReason_EndOfStream
CancellationErrorCode_NoError = _speech_py_impl.CancellationErrorCode_NoError
CancellationErrorCode_AuthenticationFailure = _speech_py_impl.CancellationErrorCode_AuthenticationFailure
CancellationErrorCode_BadRequest = _speech_py_impl.CancellationErrorCode_BadRequest
CancellationErrorCode_TooManyRequests = _speech_py_impl.CancellationErrorCode_TooManyRequests
CancellationErrorCode_Forbidden = _speech_py_impl.CancellationErrorCode_Forbidden
CancellationErrorCode_ConnectionFailure = _speech_py_impl.CancellationErrorCode_ConnectionFailure
CancellationErrorCode_ServiceTimeout = _speech_py_impl.CancellationErrorCode_ServiceTimeout
CancellationErrorCode_ServiceError = _speech_py_impl.CancellationErrorCode_ServiceError
CancellationErrorCode_ServiceUnavailable = _speech_py_impl.CancellationErrorCode_ServiceUnavailable
CancellationErrorCode_RuntimeError = _speech_py_impl.CancellationErrorCode_RuntimeError
NoMatchReason_NotRecognized = _speech_py_impl.NoMatchReason_NotRecognized
NoMatchReason_InitialSilenceTimeout = _speech_py_impl.NoMatchReason_InitialSilenceTimeout
NoMatchReason_InitialBabbleTimeout = _speech_py_impl.NoMatchReason_InitialBabbleTimeout
class SpeechRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)                                                                                      :
        return _speech_py_impl.SpeechRecognitionResultPtrFuture_get(self)
SpeechRecognitionResultPtrFuture_swigregister = _speech_py_impl.SpeechRecognitionResultPtrFuture_swigregister
SpeechRecognitionResultPtrFuture_swigregister(SpeechRecognitionResultPtrFuture)

class IntentRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)                                                                                              :
        return _speech_py_impl.IntentRecognitionResultPtrFuture_get(self)
IntentRecognitionResultPtrFuture_swigregister = _speech_py_impl.IntentRecognitionResultPtrFuture_swigregister
IntentRecognitionResultPtrFuture_swigregister(IntentRecognitionResultPtrFuture)

class TranslationRecognitionResultPtrFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionResultPtrFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionResultPtrFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionResultPtrFuture
    __del__ = lambda self: None

    def get(self)                                                                                                        :
        return _speech_py_impl.TranslationRecognitionResultPtrFuture_get(self)
TranslationRecognitionResultPtrFuture_swigregister = _speech_py_impl.TranslationRecognitionResultPtrFuture_swigregister
TranslationRecognitionResultPtrFuture_swigregister(TranslationRecognitionResultPtrFuture)

class VoidFuture(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VoidFuture, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VoidFuture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_VoidFuture
    __del__ = lambda self: None

    def get(self)          :
        return _speech_py_impl.VoidFuture_get(self)
VoidFuture_swigregister = _speech_py_impl.VoidFuture_swigregister
VoidFuture_swigregister(VoidFuture)

class SpeechConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.SpeechConfig__from_subscription)
    else:
        _from_subscription = _speech_py_impl.SpeechConfig__from_subscription
    if _newclass:
        _from_authorization_token = staticmethod(_speech_py_impl.SpeechConfig__from_authorization_token)
    else:
        _from_authorization_token = _speech_py_impl.SpeechConfig__from_authorization_token
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.SpeechConfig__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.SpeechConfig__from_endpoint

    def set_speech_recognition_language(self, lang                       )          :
        return _speech_py_impl.SpeechConfig_set_speech_recognition_language(self, lang)

    def get_speech_recognition_language(self)                 :
        return _speech_py_impl.SpeechConfig_get_speech_recognition_language(self)

    def set_endpoint_id(self, endpointId                       )          :
        return _speech_py_impl.SpeechConfig_set_endpoint_id(self, endpointId)

    def get_endpoint_id(self)                 :
        return _speech_py_impl.SpeechConfig_get_endpoint_id(self)

    def set_authorization_token(self, token                       )          :
        return _speech_py_impl.SpeechConfig_set_authorization_token(self, token)

    def get_authorization_token(self)                 :
        return _speech_py_impl.SpeechConfig_get_authorization_token(self)

    def get_subscription_key(self)                 :
        return _speech_py_impl.SpeechConfig_get_subscription_key(self)

    def get_region(self)                 :
        return _speech_py_impl.SpeechConfig_get_region(self)

    def get_output_format(self)                                                        :
        return _speech_py_impl.SpeechConfig_get_output_format(self)

    def set_output_format(self, format                                                      )          :
        return _speech_py_impl.SpeechConfig_set_output_format(self, format)

    def set_proxy(self, *args)          :
        return _speech_py_impl.SpeechConfig_set_proxy(self, *args)

    def get_property(self, *args)                 :
        return _speech_py_impl.SpeechConfig_get_property(self, *args)

    def set_property(self, *args)          :
        return _speech_py_impl.SpeechConfig_set_property(self, *args)
    __swig_destroy__ = _speech_py_impl.delete_SpeechConfig
    __del__ = lambda self: None
SpeechConfig_swigregister = _speech_py_impl.SpeechConfig_swigregister
SpeechConfig_swigregister(SpeechConfig)

def SpeechConfig__from_subscription(subscription                       , region                       )                                                                           :
    return _speech_py_impl.SpeechConfig__from_subscription(subscription, region)
SpeechConfig__from_subscription = _speech_py_impl.SpeechConfig__from_subscription

def SpeechConfig__from_authorization_token(authToken                       , region                       )                                                                           :
    return _speech_py_impl.SpeechConfig__from_authorization_token(authToken, region)
SpeechConfig__from_authorization_token = _speech_py_impl.SpeechConfig__from_authorization_token

def SpeechConfig__from_endpoint(endpoint                       , subscription                       )                                                                           :
    return _speech_py_impl.SpeechConfig__from_endpoint(endpoint, subscription)
SpeechConfig__from_endpoint = _speech_py_impl.SpeechConfig__from_endpoint

class SpeechTranslationConfig(SpeechConfig):
    __swig_setmethods__ = {}
    for _s in [SpeechConfig]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechTranslationConfig, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechConfig]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechTranslationConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_subscription)
    else:
        _from_subscription = _speech_py_impl.SpeechTranslationConfig__from_subscription
    if _newclass:
        _from_authorization_token = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_authorization_token)
    else:
        _from_authorization_token = _speech_py_impl.SpeechTranslationConfig__from_authorization_token
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.SpeechTranslationConfig__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.SpeechTranslationConfig__from_endpoint

    def add_target_language(self, language                       )          :
        return _speech_py_impl.SpeechTranslationConfig_add_target_language(self, language)

    def get_target_languages(self)                                                              :
        return _speech_py_impl.SpeechTranslationConfig_get_target_languages(self)

    def set_voice_name(self, voice                       )          :
        return _speech_py_impl.SpeechTranslationConfig_set_voice_name(self, voice)

    def get_voice_name(self)                 :
        return _speech_py_impl.SpeechTranslationConfig_get_voice_name(self)
    __swig_destroy__ = _speech_py_impl.delete_SpeechTranslationConfig
    __del__ = lambda self: None
SpeechTranslationConfig_swigregister = _speech_py_impl.SpeechTranslationConfig_swigregister
SpeechTranslationConfig_swigregister(SpeechTranslationConfig)

def SpeechTranslationConfig__from_subscription(subscription                       , region                       )                                                                                                   :
    return _speech_py_impl.SpeechTranslationConfig__from_subscription(subscription, region)
SpeechTranslationConfig__from_subscription = _speech_py_impl.SpeechTranslationConfig__from_subscription

def SpeechTranslationConfig__from_authorization_token(authToken                       , region                       )                                                                                                   :
    return _speech_py_impl.SpeechTranslationConfig__from_authorization_token(authToken, region)
SpeechTranslationConfig__from_authorization_token = _speech_py_impl.SpeechTranslationConfig__from_authorization_token

def SpeechTranslationConfig__from_endpoint(endpoint                       , subscription                       )                                                                                                   :
    return _speech_py_impl.SpeechTranslationConfig__from_endpoint(endpoint, subscription)
SpeechTranslationConfig__from_endpoint = _speech_py_impl.SpeechTranslationConfig__from_endpoint

class PropertyCollection(_object):
    """

    Class to retrieve or set a property value from a property collection.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyCollection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyCollection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PropertyCollection
    __del__ = lambda self: None

    def set_property(self, property_id              , value     ):
        if not isinstance(property_id, PropertyId):
            raise TypeError('wrong type, must be PropertyId')
        return _speech_py_impl.PropertyCollection_set_property(self, property_id.value, value)


    def get_property(self, property_id              , default_value      = '')       :
        if not isinstance(property_id, PropertyId):
            raise TypeError('wrong type, must be PropertyId')
        return _speech_py_impl.PropertyCollection_get_property(self, property_id.value, default_value)

PropertyCollection_swigregister = _speech_py_impl.PropertyCollection_swigregister
PropertyCollection_swigregister(PropertyCollection)

class AudioStreamFormat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioStreamFormat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioStreamFormat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_AudioStreamFormat
    __del__ = lambda self: None
    if _newclass:
        get_default_input_format = staticmethod(_speech_py_impl.AudioStreamFormat_get_default_input_format)
    else:
        get_default_input_format = _speech_py_impl.AudioStreamFormat_get_default_input_format
    if _newclass:
        get_wave_format_pcm = staticmethod(_speech_py_impl.AudioStreamFormat_get_wave_format_pcm)
    else:
        get_wave_format_pcm = _speech_py_impl.AudioStreamFormat_get_wave_format_pcm
AudioStreamFormat_swigregister = _speech_py_impl.AudioStreamFormat_swigregister
AudioStreamFormat_swigregister(AudioStreamFormat)

def AudioStreamFormat_get_default_input_format()                                                                                       :
    return _speech_py_impl.AudioStreamFormat_get_default_input_format()
AudioStreamFormat_get_default_input_format = _speech_py_impl.AudioStreamFormat_get_default_input_format

def AudioStreamFormat_get_wave_format_pcm(samplesPerSecond            , bitsPerSample           =16, channels           =1)                                                                                       :
    return _speech_py_impl.AudioStreamFormat_get_wave_format_pcm(samplesPerSecond, bitsPerSample, channels)
AudioStreamFormat_get_wave_format_pcm = _speech_py_impl.AudioStreamFormat_get_wave_format_pcm

class AudioInputStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioInputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_AudioInputStream
    __del__ = lambda self: None
AudioInputStream_swigregister = _speech_py_impl.AudioInputStream_swigregister
AudioInputStream_swigregister(AudioInputStream)

class PushAudioInputStream(AudioInputStream):
    __swig_setmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PushAudioInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PushAudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PushAudioInputStream
    __del__ = lambda self: None
    if _newclass:
        create = staticmethod(_speech_py_impl.PushAudioInputStream_create)
    else:
        create = _speech_py_impl.PushAudioInputStream_create

    def write(self, dataBuffer             )          :
        return _speech_py_impl.PushAudioInputStream_write(self, dataBuffer)

    def close(self)          :
        return _speech_py_impl.PushAudioInputStream_close(self)
PushAudioInputStream_swigregister = _speech_py_impl.PushAudioInputStream_swigregister
PushAudioInputStream_swigregister(PushAudioInputStream)

def PushAudioInputStream_create(*args)                                                                                          :
    return _speech_py_impl.PushAudioInputStream_create(*args)
PushAudioInputStream_create = _speech_py_impl.PushAudioInputStream_create

class PullAudioInputStreamCallback(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PullAudioInputStreamCallback, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PullAudioInputStreamCallback, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_PullAudioInputStreamCallback
    __del__ = lambda self: None

    def read(self, dataBuffer             )         :
        return _speech_py_impl.PullAudioInputStreamCallback_read(self, dataBuffer)

    def close(self)          :
        return _speech_py_impl.PullAudioInputStreamCallback_close(self)

    def __init__(self):
        if self.__class__ == PullAudioInputStreamCallback:
            _self = None
        else:
            _self = self
        this = _speech_py_impl.new_PullAudioInputStreamCallback(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    def __disown__(self):
        self.this.disown()
        _speech_py_impl.disown_PullAudioInputStreamCallback(self)
        return weakref_proxy(self)
PullAudioInputStreamCallback_swigregister = _speech_py_impl.PullAudioInputStreamCallback_swigregister
PullAudioInputStreamCallback_swigregister(PullAudioInputStreamCallback)

class PullAudioInputStream(AudioInputStream):
    __swig_setmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PullAudioInputStream, name, value)
    __swig_getmethods__ = {}
    for _s in [AudioInputStream]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PullAudioInputStream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        create = staticmethod(_speech_py_impl.PullAudioInputStream_create)
    else:
        create = _speech_py_impl.PullAudioInputStream_create
    __swig_destroy__ = _speech_py_impl.delete_PullAudioInputStream
    __del__ = lambda self: None
PullAudioInputStream_swigregister = _speech_py_impl.PullAudioInputStream_swigregister
PullAudioInputStream_swigregister(PullAudioInputStream)

def PullAudioInputStream_create(*args)                                                                                          :
    return _speech_py_impl.PullAudioInputStream_create(*args)
PullAudioInputStream_create = _speech_py_impl.PullAudioInputStream_create

class AudioConfig(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AudioConfig, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AudioConfig, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_default_microphone_input = staticmethod(_speech_py_impl.AudioConfig__from_default_microphone_input)
    else:
        _from_default_microphone_input = _speech_py_impl.AudioConfig__from_default_microphone_input
    if _newclass:
        _from_wav_file_input = staticmethod(_speech_py_impl.AudioConfig__from_wav_file_input)
    else:
        _from_wav_file_input = _speech_py_impl.AudioConfig__from_wav_file_input
    if _newclass:
        _from_stream_input = staticmethod(_speech_py_impl.AudioConfig__from_stream_input)
    else:
        _from_stream_input = _speech_py_impl.AudioConfig__from_stream_input
    __swig_destroy__ = _speech_py_impl.delete_AudioConfig
    __del__ = lambda self: None
AudioConfig_swigregister = _speech_py_impl.AudioConfig_swigregister
AudioConfig_swigregister(AudioConfig)

def AudioConfig__from_default_microphone_input()                                                                                 :
    return _speech_py_impl.AudioConfig__from_default_microphone_input()
AudioConfig__from_default_microphone_input = _speech_py_impl.AudioConfig__from_default_microphone_input

def AudioConfig__from_wav_file_input(fileName                       )                                                                                 :
    return _speech_py_impl.AudioConfig__from_wav_file_input(fileName)
AudioConfig__from_wav_file_input = _speech_py_impl.AudioConfig__from_wav_file_input

def AudioConfig__from_stream_input(stream                                                                                    )                                                                                 :
    return _speech_py_impl.AudioConfig__from_stream_input(stream)
AudioConfig__from_stream_input = _speech_py_impl.AudioConfig__from_stream_input

class KeywordRecognitionModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeywordRecognitionModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeywordRecognitionModel, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_file = staticmethod(_speech_py_impl.KeywordRecognitionModel__from_file)
    else:
        _from_file = _speech_py_impl.KeywordRecognitionModel__from_file

    def __init__(self, *args):
        this = _speech_py_impl.new_KeywordRecognitionModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_KeywordRecognitionModel
    __del__ = lambda self: None

    def __new__(cls, filename              =None):
        if filename is None:
            return super().__new__(cls)

        return cls._from_file(filename)

    def __init__(self, filename=None):
        if filename is None:
            raise ValueError('a filename needs to be provided')

KeywordRecognitionModel_swigregister = _speech_py_impl.KeywordRecognitionModel_swigregister
KeywordRecognitionModel_swigregister(KeywordRecognitionModel)

def KeywordRecognitionModel__from_file(fileName                       )                                                                                      :
    return _speech_py_impl.KeywordRecognitionModel__from_file(fileName)
KeywordRecognitionModel__from_file = _speech_py_impl.KeywordRecognitionModel__from_file

class EventArgs(_object):
    """

    Base class for event arguments.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventArgs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_EventArgs
    __del__ = lambda self: None
EventArgs_swigregister = _speech_py_impl.EventArgs_swigregister
EventArgs_swigregister(EventArgs)

class SessionEventArgs(EventArgs):
    """

    Base class for session event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [EventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SessionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [EventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SessionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SessionEventArgs
    __del__ = lambda self: None
    __swig_getmethods__["session_id"] = _speech_py_impl.SessionEventArgs_session_id_get
    if _newclass:
        session_id = _swig_property(_speech_py_impl.SessionEventArgs_session_id_get)

    def __str__(self):
        return u'{}:(session_id={})'.format(type(self), self.session_id)

SessionEventArgs_swigregister = _speech_py_impl.SessionEventArgs_swigregister
SessionEventArgs_swigregister(SessionEventArgs)

class ConnectionEventArgs(SessionEventArgs):
    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionEventArgs, name)
    __repr__ = _swig_repr

    def __init__(self, hevent                  ):
        this = _speech_py_impl.new_ConnectionEventArgs(hevent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_ConnectionEventArgs
    __del__ = lambda self: None
ConnectionEventArgs_swigregister = _speech_py_impl.ConnectionEventArgs_swigregister
ConnectionEventArgs_swigregister(ConnectionEventArgs)

class RecognitionResult(_object):
    """

    Contains detailed information about the result of a recognition operation.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["result_id"] = _speech_py_impl.RecognitionResult_result_id_get
    if _newclass:
        result_id = _swig_property(_speech_py_impl.RecognitionResult_result_id_get)
    __swig_getmethods__["_reason"] = _speech_py_impl.RecognitionResult__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.RecognitionResult__reason_get)
    __swig_getmethods__["text"] = _speech_py_impl.RecognitionResult_text_get
    if _newclass:
        text = _swig_property(_speech_py_impl.RecognitionResult_text_get)

    def duration(self)              :
        """


        Duration of recognized speech in ticks. A single tick represents one hundred
        nanoseconds or one ten-millionth of a second.

        :return: Duration of recognized speech in ticks.

        """
        return _speech_py_impl.RecognitionResult_duration(self)


    def offset(self)              :
        """


        Offset of the recognized speech in ticks. A single tick represents one hundred
        nanoseconds or one ten-millionth of a second.

        :return: Offset of the recognized speech in ticks.

        """
        return _speech_py_impl.RecognitionResult_offset(self)

    __swig_getmethods__["properties"] = _speech_py_impl.RecognitionResult_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.RecognitionResult_properties_get)

    def __str__(self):
        return u'{}:(result_id={}, text={})'.format(type(self), self.result_id, self.text)


    @property
    def reason(self)                  :
        """
        The recognition reason
        """
        return ResultReason(self._reason)


    __swig_getmethods__["offset"] = _speech_py_impl.RecognitionResult_offset
    if _newclass: offset = property(_speech_py_impl.RecognitionResult_offset)

    __swig_getmethods__["duration"] = _speech_py_impl.RecognitionResult_duration
    if _newclass: duration = property(_speech_py_impl.RecognitionResult_duration)

    @property
    def json(self)       :
        """The bare JSON representation of the result from the Speech Service."""
        return self.properties.get_property(PropertyId.SpeechServiceResponse_JsonResult)
    @property
    def error_json(self)       :
        """The bare JSON representation of the error from the Speech Service."""
        return self.properties.get_property(PropertyId.SpeechServiceResponse_JsonErrorDetails)
    @property
    def cancellation_details(self)                         :
        """The reason why recognition was cancelled.

        Returns `None` if there was no cancellation."""
        if ResultReason.Canceled == self.reason:
            return CancellationDetails._from_result(self)
    @property
    def no_match_details(self)                    :
        """Detailed information for NoMatch recognition results.

        Returns `None` if there was a match found."""
        if ResultReason.NoMatch == self.reason:
            return NoMatchDetails._from_result(self) 
RecognitionResult_swigregister = _speech_py_impl.RecognitionResult_swigregister
RecognitionResult_swigregister(RecognitionResult)

class CancellationDetails(_object):
    """

    Contains detailed information about why a result was canceled.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CancellationDetails, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CancellationDetails, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _from_result(result                                                                              )                                                                                  :
        """

        Creates an instance of CancellationDetails object for the canceled
        RecognitionResult.

        :param result: The result that was canceled.
        :return: A CancellationDetails instance.

        """
        return _speech_py_impl.CancellationDetails__from_result(result)

    _from_result = staticmethod(_from_result)
    __swig_getmethods__["_reason"] = _speech_py_impl.CancellationDetails__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.CancellationDetails__reason_get)
    __swig_getmethods__["error_code"] = _speech_py_impl.CancellationDetails_error_code_get
    if _newclass:
        error_code = _swig_property(_speech_py_impl.CancellationDetails_error_code_get)
    __swig_getmethods__["error_details"] = _speech_py_impl.CancellationDetails_error_details_get
    if _newclass:
        error_details = _swig_property(_speech_py_impl.CancellationDetails_error_details_get)

    @property
    def reason(self)                        :
        """
        The reason the result was canceled.
        """
        return CancellationReason(self._reason)

    __swig_destroy__ = _speech_py_impl.delete_CancellationDetails
    __del__ = lambda self: None
CancellationDetails_swigregister = _speech_py_impl.CancellationDetails_swigregister
CancellationDetails_swigregister(CancellationDetails)

def CancellationDetails__from_result(result                                                                              )                                                                                  :
    """

    Creates an instance of CancellationDetails object for the canceled
    RecognitionResult.

    :param result: The result that was canceled.
    :return: A CancellationDetails instance.

    """
    return _speech_py_impl.CancellationDetails__from_result(result)

class NoMatchDetails(_object):
    """

    Detailed information for NoMatch recognition results.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoMatchDetails, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NoMatchDetails, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        _from_result = staticmethod(_speech_py_impl.NoMatchDetails__from_result)
    else:
        _from_result = _speech_py_impl.NoMatchDetails__from_result
    __swig_getmethods__["_reason"] = _speech_py_impl.NoMatchDetails__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.NoMatchDetails__reason_get)

    @property
    def reason(self)                   :
        """
        The reason for the NoMatch result
        """
        return NoMatchReason(self._reason)

    __swig_destroy__ = _speech_py_impl.delete_NoMatchDetails
    __del__ = lambda self: None
NoMatchDetails_swigregister = _speech_py_impl.NoMatchDetails_swigregister
NoMatchDetails_swigregister(NoMatchDetails)

def NoMatchDetails__from_result(result                                                                              )                                                                             :
    return _speech_py_impl.NoMatchDetails__from_result(result)
NoMatchDetails__from_result = _speech_py_impl.NoMatchDetails__from_result

class RecognitionEventArgs(SessionEventArgs):
    """

    Provides data for the RecognitionEvent.

    """

    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionEventArgs
    __del__ = lambda self: None
    __swig_getmethods__["offset"] = _speech_py_impl.RecognitionEventArgs_offset_get
    if _newclass:
        offset = _swig_property(_speech_py_impl.RecognitionEventArgs_offset_get)
RecognitionEventArgs_swigregister = _speech_py_impl.RecognitionEventArgs_swigregister
RecognitionEventArgs_swigregister(RecognitionEventArgs)

class SessionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SessionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SessionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SessionEventSignal
    __del__ = lambda self: None

    def __call__(self, t                    )          :
        return _speech_py_impl.SessionEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SessionEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SessionEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SessionEventSignal_connect(self, func, wrapped_type)

SessionEventSignal_swigregister = _speech_py_impl.SessionEventSignal_swigregister
SessionEventSignal_swigregister(SessionEventSignal)

class RecognitionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RecognitionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RecognitionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_RecognitionEventSignal
    __del__ = lambda self: None

    def __call__(self, t                        )          :
        return _speech_py_impl.RecognitionEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.RecognitionEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.RecognitionEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.RecognitionEventSignal_connect(self, func, wrapped_type)

RecognitionEventSignal_swigregister = _speech_py_impl.RecognitionEventSignal_swigregister
RecognitionEventSignal_swigregister(RecognitionEventSignal)

class ConnectionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_ConnectionEventSignal
    __del__ = lambda self: None

    def __call__(self, t                       )          :
        return _speech_py_impl.ConnectionEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.ConnectionEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.ConnectionEventSignal_is_connected(self)

ConnectionEventSignal_swigregister = _speech_py_impl.ConnectionEventSignal_swigregister
ConnectionEventSignal_swigregister(ConnectionEventSignal)

class Recognizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Recognizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Recognizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def is_enabled(self)          :
        return _speech_py_impl.Recognizer_is_enabled(self)

    def enable(self)          :
        return _speech_py_impl.Recognizer_enable(self)

    def disable(self)          :
        return _speech_py_impl.Recognizer_disable(self)
    __swig_destroy__ = _speech_py_impl.delete_Recognizer
    __del__ = lambda self: None

    __swig_getmethods__["is_enabled"] = _speech_py_impl.Recognizer_is_enabled
    if _newclass: is_enabled = property(_speech_py_impl.Recognizer_is_enabled)
Recognizer_swigregister = _speech_py_impl.Recognizer_swigregister
Recognizer_swigregister(Recognizer)

class BaseRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.BaseRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.BaseRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.BaseRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.BaseRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.BaseRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.BaseRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.BaseRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.BaseRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.BaseRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.BaseRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.BaseRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.BaseRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.BaseRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.BaseRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_BaseRecognizerBase
    __del__ = lambda self: None
BaseRecognizerBase_swigregister = _speech_py_impl.BaseRecognizerBase_swigregister
BaseRecognizerBase_swigregister(BaseRecognizerBase)

class BaseAsyncRecognizer(BaseRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [BaseRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseAsyncRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BaseAsyncRecognizer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_BaseAsyncRecognizer
    __del__ = lambda self: None
BaseAsyncRecognizer_swigregister = _speech_py_impl.BaseAsyncRecognizer_swigregister
BaseAsyncRecognizer_swigregister(BaseAsyncRecognizer)

class SpeechRecognitionResult(RecognitionResult):
    """

    Base class for speech recognition results.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionResult
    __del__ = lambda self: None
SpeechRecognitionResult_swigregister = _speech_py_impl.SpeechRecognitionResult_swigregister
SpeechRecognitionResult_swigregister(SpeechRecognitionResult)

class SpeechRecognitionEventArgs(RecognitionEventArgs):
    """

    Class for speech recognition event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)                                                                                      :
        return _speech_py_impl.SpeechRecognitionEventArgs__get_result(self)

    def __str__(self):
        return u'{}:(session_id={}, result={})'.format(type(self), self.session_id, self.result)


    @property
    def result(self)                             :
        """
        Contains the speech recognition result.
        """
        return self._get_result()

SpeechRecognitionEventArgs_swigregister = _speech_py_impl.SpeechRecognitionEventArgs_swigregister
SpeechRecognitionEventArgs_swigregister(SpeechRecognitionEventArgs)

class SpeechRecognitionCanceledEventArgs(SpeechRecognitionEventArgs):
    """

    Class for speech recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [SpeechRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)                                                                                  :
        return _speech_py_impl.SpeechRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)                         :
        """
        Details about why speech recognition was canceled.
        """
        return self._get_cancellation_details()

SpeechRecognitionCanceledEventArgs_swigregister = _speech_py_impl.SpeechRecognitionCanceledEventArgs_swigregister
SpeechRecognitionCanceledEventArgs_swigregister(SpeechRecognitionCanceledEventArgs)

class SpeechRecognitionEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionEventSignal
    __del__ = lambda self: None

    def __call__(self, t                              )          :
        return _speech_py_impl.SpeechRecognitionEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechRecognitionEventSignal_connect(self, func, wrapped_type)

SpeechRecognitionEventSignal_swigregister = _speech_py_impl.SpeechRecognitionEventSignal_swigregister
SpeechRecognitionEventSignal_swigregister(SpeechRecognitionEventSignal)

class SpeechRecognitionCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognitionCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognitionCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognitionCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t                                      )          :
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.SpeechRecognitionCanceledEventSignal_connect(self, func, wrapped_type)

SpeechRecognitionCanceledEventSignal_swigregister = _speech_py_impl.SpeechRecognitionCanceledEventSignal_swigregister
SpeechRecognitionCanceledEventSignal_swigregister(SpeechRecognitionCanceledEventSignal)

class SpeechRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.SpeechRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.SpeechRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.SpeechRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.SpeechRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.SpeechRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.SpeechRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.SpeechRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.SpeechRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.SpeechRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.SpeechRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.SpeechRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.SpeechRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.SpeechRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.SpeechRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognizerBase
    __del__ = lambda self: None
SpeechRecognizerBase_swigregister = _speech_py_impl.SpeechRecognizerBase_swigregister
SpeechRecognizerBase_swigregister(SpeechRecognizerBase)

class SpeechRecognizer(SpeechRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [SpeechRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpeechRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [SpeechRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpeechRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.SpeechRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.SpeechRecognizer__from_config

    def __init__(self, hreco                 ):
        this = _speech_py_impl.new_SpeechRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_SpeechRecognizer
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.SpeechRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.SpeechRecognizer_properties_get)

    def get_endpoint_id(self)                 :
        return _speech_py_impl.SpeechRecognizer_get_endpoint_id(self)

    def set_authorization_token(self, token                       )          :
        return _speech_py_impl.SpeechRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)                 :
        return _speech_py_impl.SpeechRecognizer_get_authorization_token(self)

    def recognize_once(self)                                :
        return _speech_py_impl.SpeechRecognizer_recognize_once(self)

    def start_continuous_recognition(self)          :
        return _speech_py_impl.SpeechRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)          :
        return _speech_py_impl.SpeechRecognizer_stop_continuous_recognition(self)

    def recognize_once_async(self)                                                 :
        return _speech_py_impl.SpeechRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)                           :
        return _speech_py_impl.SpeechRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)                           :
        return _speech_py_impl.SpeechRecognizer_stop_continuous_recognition_async(self)
SpeechRecognizer_swigregister = _speech_py_impl.SpeechRecognizer_swigregister
SpeechRecognizer_swigregister(SpeechRecognizer)

def SpeechRecognizer__from_config(speechconfig                                                                         , audioInput                                                                               =0)                                                                               :
    return _speech_py_impl.SpeechRecognizer__from_config(speechconfig, audioInput)
SpeechRecognizer__from_config = _speech_py_impl.SpeechRecognizer__from_config

class IntentRecognitionResult(RecognitionResult):
    """

    Represents the result of an intent recognition.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["intent_id"] = _speech_py_impl.IntentRecognitionResult_intent_id_get
    if _newclass:
        intent_id = _swig_property(_speech_py_impl.IntentRecognitionResult_intent_id_get)

    @property
    def intent_json(self)       :
        """The bare JSON representation of the result from the Language Understanding service."""
        return self.properties.get_property(PropertyId.LanguageUnderstandingServiceResponse_JsonResult)

IntentRecognitionResult_swigregister = _speech_py_impl.IntentRecognitionResult_swigregister
IntentRecognitionResult_swigregister(IntentRecognitionResult)

class IntentRecognitionEventArgs(RecognitionEventArgs):
    """

    Class for intent recognition event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)                                                                                              :
        return _speech_py_impl.IntentRecognitionEventArgs__get_result(self)

    @property
    def result(self)                                :
        """
        Contains the intent recognition result.
        """
        return self._get_result()

IntentRecognitionEventArgs_swigregister = _speech_py_impl.IntentRecognitionEventArgs_swigregister
IntentRecognitionEventArgs_swigregister(IntentRecognitionEventArgs)

class IntentRecognitionCanceledEventArgs(IntentRecognitionEventArgs):
    """

    Class for intent recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [IntentRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [IntentRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)                                                                                  :
        return _speech_py_impl.IntentRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)                         :
        """
        Details about why intent recognition was canceled.
        """
        return self._get_cancellation_details()

IntentRecognitionCanceledEventArgs_swigregister = _speech_py_impl.IntentRecognitionCanceledEventArgs_swigregister
IntentRecognitionCanceledEventArgs_swigregister(IntentRecognitionCanceledEventArgs)

class LanguageUnderstandingModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LanguageUnderstandingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LanguageUnderstandingModel, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_endpoint = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_endpoint)
    else:
        _from_endpoint = _speech_py_impl.LanguageUnderstandingModel__from_endpoint
    if _newclass:
        _from_app_id = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_app_id)
    else:
        _from_app_id = _speech_py_impl.LanguageUnderstandingModel__from_app_id
    if _newclass:
        _from_subscription = staticmethod(_speech_py_impl.LanguageUnderstandingModel__from_subscription)
    else:
        _from_subscription = _speech_py_impl.LanguageUnderstandingModel__from_subscription

    def __init__(self, *args):
        this = _speech_py_impl.new_LanguageUnderstandingModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_LanguageUnderstandingModel
    __del__ = lambda self: None
LanguageUnderstandingModel_swigregister = _speech_py_impl.LanguageUnderstandingModel_swigregister
LanguageUnderstandingModel_swigregister(LanguageUnderstandingModel)

def LanguageUnderstandingModel__from_endpoint(uri                       )                                                                                                 :
    return _speech_py_impl.LanguageUnderstandingModel__from_endpoint(uri)
LanguageUnderstandingModel__from_endpoint = _speech_py_impl.LanguageUnderstandingModel__from_endpoint

def LanguageUnderstandingModel__from_app_id(appId                       )                                                                                                 :
    return _speech_py_impl.LanguageUnderstandingModel__from_app_id(appId)
LanguageUnderstandingModel__from_app_id = _speech_py_impl.LanguageUnderstandingModel__from_app_id

def LanguageUnderstandingModel__from_subscription(subscriptionKey                       , appId                       , region                       )                                                                                                 :
    return _speech_py_impl.LanguageUnderstandingModel__from_subscription(subscriptionKey, appId, region)
LanguageUnderstandingModel__from_subscription = _speech_py_impl.LanguageUnderstandingModel__from_subscription

class IntentTrigger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentTrigger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentTrigger, name)
    __repr__ = _swig_repr
    if _newclass:
        _From = staticmethod(_speech_py_impl.IntentTrigger__From)
    else:
        _From = _speech_py_impl.IntentTrigger__From
    __swig_destroy__ = _speech_py_impl.delete_IntentTrigger
    __del__ = lambda self: None

    def __init__(self, htrigger                    ):
        this = _speech_py_impl.new_IntentTrigger(htrigger)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
IntentTrigger_swigregister = _speech_py_impl.IntentTrigger_swigregister
IntentTrigger_swigregister(IntentTrigger)

def IntentTrigger__From(*args)                                                                                    :
    return _speech_py_impl.IntentTrigger__From(*args)
IntentTrigger__From = _speech_py_impl.IntentTrigger__From

class IntentEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentEventSignal
    __del__ = lambda self: None

    def __call__(self, t                              )          :
        return _speech_py_impl.IntentEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.IntentEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.IntentEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.IntentEventSignal_connect(self, func, wrapped_type)

IntentEventSignal_swigregister = _speech_py_impl.IntentEventSignal_swigregister
IntentEventSignal_swigregister(IntentEventSignal)

class IntentCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntentCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_IntentCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t                                      )          :
        return _speech_py_impl.IntentCanceledEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.IntentCanceledEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.IntentCanceledEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.IntentCanceledEventSignal_connect(self, func, wrapped_type)

IntentCanceledEventSignal_swigregister = _speech_py_impl.IntentCanceledEventSignal_swigregister
IntentCanceledEventSignal_swigregister(IntentCanceledEventSignal)

class IntentRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.IntentRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.IntentRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.IntentRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.IntentRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.IntentRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.IntentRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.IntentRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.IntentRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.IntentRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.IntentRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.IntentRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.IntentRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.IntentRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.IntentRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognizerBase
    __del__ = lambda self: None
IntentRecognizerBase_swigregister = _speech_py_impl.IntentRecognizerBase_swigregister
IntentRecognizerBase_swigregister(IntentRecognizerBase)

class IntentRecognizer(IntentRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [IntentRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntentRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [IntentRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntentRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.IntentRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.IntentRecognizer__from_config

    def __init__(self, hreco                 ):
        this = _speech_py_impl.new_IntentRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_IntentRecognizer
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.IntentRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.IntentRecognizer_properties_get)

    def add_all_intents(self, *args)          :
        return _speech_py_impl.IntentRecognizer_add_all_intents(self, *args)

    def add_intent(self, *args)          :
        return _speech_py_impl.IntentRecognizer_add_intent(self, *args)

    def set_authorization_token(self, token                       )          :
        return _speech_py_impl.IntentRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)                 :
        return _speech_py_impl.IntentRecognizer_get_authorization_token(self)

    def recognize_once(self)                                :
        return _speech_py_impl.IntentRecognizer_recognize_once(self)

    def start_continuous_recognition(self)          :
        return _speech_py_impl.IntentRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)          :
        return _speech_py_impl.IntentRecognizer_stop_continuous_recognition(self)

    def recognize_once_async(self)                                                 :
        return _speech_py_impl.IntentRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)                           :
        return _speech_py_impl.IntentRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)                           :
        return _speech_py_impl.IntentRecognizer_stop_continuous_recognition_async(self)
IntentRecognizer_swigregister = _speech_py_impl.IntentRecognizer_swigregister
IntentRecognizer_swigregister(IntentRecognizer)

def IntentRecognizer__from_config(speechConfig                                                                         , audioInput                                                                               =0)                                                                                       :
    return _speech_py_impl.IntentRecognizer__from_config(speechConfig, audioInput)
IntentRecognizer__from_config = _speech_py_impl.IntentRecognizer__from_config

class TranslationRecognitionResult(RecognitionResult):
    """

    Defines the translation text result.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionResult, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionResult
    __del__ = lambda self: None
    __swig_getmethods__["translations"] = _speech_py_impl.TranslationRecognitionResult_translations_get
    if _newclass:
        translations = _swig_property(_speech_py_impl.TranslationRecognitionResult_translations_get)
TranslationRecognitionResult_swigregister = _speech_py_impl.TranslationRecognitionResult_swigregister
TranslationRecognitionResult_swigregister(TranslationRecognitionResult)

class TranslationSynthesisResult(_object):
    """

    Defines the translation synthesis result, i.e. the voice output of the translated text in the target language.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisResult
    __del__ = lambda self: None
    __swig_getmethods__["_reason"] = _speech_py_impl.TranslationSynthesisResult__reason_get
    if _newclass:
        _reason = _swig_property(_speech_py_impl.TranslationSynthesisResult__reason_get)
    __swig_getmethods__["_audio"] = _speech_py_impl.TranslationSynthesisResult__audio_get
    if _newclass:
        _audio = _swig_property(_speech_py_impl.TranslationSynthesisResult__audio_get)

    @property
    def audio(self)         :
        """The synthesized translation result as a `bytes` object"""
        return bytes(_speech_py_impl.TranslationSynthesisResult__audio_get(self))

    @property
    def reason(self)                  :
        """
        The reason for the result
        """
        return ResultReason(self._reason)

TranslationSynthesisResult_swigregister = _speech_py_impl.TranslationSynthesisResult_swigregister
TranslationSynthesisResult_swigregister(TranslationSynthesisResult)

class TranslationRecognitionEventArgs(RecognitionEventArgs):
    """

    Defines payload that is sent with the event Recognizing or Recognized.

    """

    __swig_setmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [RecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionEventArgs
    __del__ = lambda self: None

    def _get_result(self)                                                                                                        :
        return _speech_py_impl.TranslationRecognitionEventArgs__get_result(self)

    @property
    def result(self)                                  :
        """
        Contains the translation recognition result.
        """
        return self._get_result()

TranslationRecognitionEventArgs_swigregister = _speech_py_impl.TranslationRecognitionEventArgs_swigregister
TranslationRecognitionEventArgs_swigregister(TranslationRecognitionEventArgs)

class TranslationRecognitionCanceledEventArgs(TranslationRecognitionEventArgs):
    """

    Class for translation recognition canceled event arguments.

    """

    __swig_setmethods__ = {}
    for _s in [TranslationRecognitionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognitionCanceledEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [TranslationRecognitionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognitionCanceledEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognitionCanceledEventArgs
    __del__ = lambda self: None

    def _get_cancellation_details(self)                                                                                  :
        return _speech_py_impl.TranslationRecognitionCanceledEventArgs__get_cancellation_details(self)

    @property
    def cancellation_details(self)                         :
        """
        Details about why translation was canceled.
        """
        return self._get_cancellation_details()

TranslationRecognitionCanceledEventArgs_swigregister = _speech_py_impl.TranslationRecognitionCanceledEventArgs_swigregister
TranslationRecognitionCanceledEventArgs_swigregister(TranslationRecognitionCanceledEventArgs)

class TranslationSynthesisEventArgs(SessionEventArgs):
    """

    Defines payload that is sent with the event :py:attr:`TranslationRecognizer.synthesizing`.

    """

    __swig_setmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisEventArgs, name, value)
    __swig_getmethods__ = {}
    for _s in [SessionEventArgs]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisEventArgs, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisEventArgs
    __del__ = lambda self: None

    def _get_result(self)                                                                                                      :
        return _speech_py_impl.TranslationSynthesisEventArgs__get_result(self)

    @property
    def result(self)                                :
        """
        Contains the translation synthesis result.
        """
        return self._get_result()

TranslationSynthesisEventArgs_swigregister = _speech_py_impl.TranslationSynthesisEventArgs_swigregister
TranslationSynthesisEventArgs_swigregister(TranslationSynthesisEventArgs)

class TranslationTextEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationTextEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationTextEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationTextEventSignal
    __del__ = lambda self: None

    def __call__(self, t                                   )          :
        return _speech_py_impl.TranslationTextEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationTextEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationTextEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationTextEventSignal_connect(self, func, wrapped_type)

TranslationTextEventSignal_swigregister = _speech_py_impl.TranslationTextEventSignal_swigregister
TranslationTextEventSignal_swigregister(TranslationTextEventSignal)

class TranslationTextCanceledEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationTextCanceledEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationTextCanceledEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationTextCanceledEventSignal
    __del__ = lambda self: None

    def __call__(self, t                                           )          :
        return _speech_py_impl.TranslationTextCanceledEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationTextCanceledEventSignal_connect(self, func, wrapped_type)

TranslationTextCanceledEventSignal_swigregister = _speech_py_impl.TranslationTextCanceledEventSignal_swigregister
TranslationTextCanceledEventSignal_swigregister(TranslationTextCanceledEventSignal)

class TranslationSynthesisEventSignal(_object):
    """

    Clients can connect to the event signal to receive events, or disconnect from
    the event signal to stop receiving events.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationSynthesisEventSignal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationSynthesisEventSignal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _speech_py_impl.delete_TranslationSynthesisEventSignal
    __del__ = lambda self: None

    def __call__(self, t                                 )          :
        return _speech_py_impl.TranslationSynthesisEventSignal___call__(self, t)

    def disconnect_all(self)          :
        """

        Disconnects all registered callbacks.

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_disconnect_all(self)


    def is_connected(self)          :
        """

        Checks if a callback is connected.

        :return: True if a callback is connected

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_is_connected(self)


    def connect(self, func              , wrapped_type              )          :
        """

        Connects given callback function to the event signal, to be invoked when the
        event is signalled.

        :param callback: Callback to connect.

        """
        return _speech_py_impl.TranslationSynthesisEventSignal_connect(self, func, wrapped_type)

TranslationSynthesisEventSignal_swigregister = _speech_py_impl.TranslationSynthesisEventSignal_swigregister
TranslationSynthesisEventSignal_swigregister(TranslationSynthesisEventSignal)

class TranslationRecognizerBase(Recognizer):
    __swig_setmethods__ = {}
    for _s in [Recognizer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognizerBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Recognizer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognizerBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_getmethods__["session_started"] = _speech_py_impl.TranslationRecognizerBase_session_started_get
    if _newclass:
        session_started = _swig_property(_speech_py_impl.TranslationRecognizerBase_session_started_get)
    __swig_getmethods__["session_stopped"] = _speech_py_impl.TranslationRecognizerBase_session_stopped_get
    if _newclass:
        session_stopped = _swig_property(_speech_py_impl.TranslationRecognizerBase_session_stopped_get)
    __swig_getmethods__["speech_start_detected"] = _speech_py_impl.TranslationRecognizerBase_speech_start_detected_get
    if _newclass:
        speech_start_detected = _swig_property(_speech_py_impl.TranslationRecognizerBase_speech_start_detected_get)
    __swig_getmethods__["speech_end_detected"] = _speech_py_impl.TranslationRecognizerBase_speech_end_detected_get
    if _newclass:
        speech_end_detected = _swig_property(_speech_py_impl.TranslationRecognizerBase_speech_end_detected_get)
    __swig_getmethods__["recognizing"] = _speech_py_impl.TranslationRecognizerBase_recognizing_get
    if _newclass:
        recognizing = _swig_property(_speech_py_impl.TranslationRecognizerBase_recognizing_get)
    __swig_getmethods__["recognized"] = _speech_py_impl.TranslationRecognizerBase_recognized_get
    if _newclass:
        recognized = _swig_property(_speech_py_impl.TranslationRecognizerBase_recognized_get)
    __swig_getmethods__["canceled"] = _speech_py_impl.TranslationRecognizerBase_canceled_get
    if _newclass:
        canceled = _swig_property(_speech_py_impl.TranslationRecognizerBase_canceled_get)
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognizerBase
    __del__ = lambda self: None
TranslationRecognizerBase_swigregister = _speech_py_impl.TranslationRecognizerBase_swigregister
TranslationRecognizerBase_swigregister(TranslationRecognizerBase)

class TranslationRecognizer(TranslationRecognizerBase):
    __swig_setmethods__ = {}
    for _s in [TranslationRecognizerBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TranslationRecognizer, name, value)
    __swig_getmethods__ = {}
    for _s in [TranslationRecognizerBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TranslationRecognizer, name)
    __repr__ = _swig_repr
    if _newclass:
        _from_config = staticmethod(_speech_py_impl.TranslationRecognizer__from_config)
    else:
        _from_config = _speech_py_impl.TranslationRecognizer__from_config

    def __init__(self, hreco                 ):
        this = _speech_py_impl.new_TranslationRecognizer(hreco)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_TranslationRecognizer
    __del__ = lambda self: None

    def set_authorization_token(self, token                       )          :
        return _speech_py_impl.TranslationRecognizer_set_authorization_token(self, token)

    def get_authorization_token(self)                 :
        return _speech_py_impl.TranslationRecognizer_get_authorization_token(self)
    __swig_getmethods__["properties"] = _speech_py_impl.TranslationRecognizer_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.TranslationRecognizer_properties_get)
    __swig_getmethods__["synthesizing"] = _speech_py_impl.TranslationRecognizer_synthesizing_get
    if _newclass:
        synthesizing = _swig_property(_speech_py_impl.TranslationRecognizer_synthesizing_get)

    def recognize_once(self)                                     :
        return _speech_py_impl.TranslationRecognizer_recognize_once(self)

    def start_continuous_recognition(self)          :
        return _speech_py_impl.TranslationRecognizer_start_continuous_recognition(self)

    def stop_continuous_recognition(self)          :
        return _speech_py_impl.TranslationRecognizer_stop_continuous_recognition(self)

    def recognize_once_async(self)                                                      :
        return _speech_py_impl.TranslationRecognizer_recognize_once_async(self)

    def start_continuous_recognition_async(self)                           :
        return _speech_py_impl.TranslationRecognizer_start_continuous_recognition_async(self)

    def stop_continuous_recognition_async(self)                           :
        return _speech_py_impl.TranslationRecognizer_stop_continuous_recognition_async(self)
TranslationRecognizer_swigregister = _speech_py_impl.TranslationRecognizer_swigregister
TranslationRecognizer_swigregister(TranslationRecognizer)

def TranslationRecognizer__from_config(speechconfig                                                                                                 , audioInput                                                                               =0)                                                                                                 :
    return _speech_py_impl.TranslationRecognizer__from_config(speechconfig, audioInput)
TranslationRecognizer__from_config = _speech_py_impl.TranslationRecognizer__from_config

class Session(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Session, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Session, name)
    __repr__ = _swig_repr

    def __init__(self, hsession                    ):
        this = _speech_py_impl.new_Session(hsession)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Session
    __del__ = lambda self: None
    __swig_getmethods__["properties"] = _speech_py_impl.Session_properties_get
    if _newclass:
        properties = _swig_property(_speech_py_impl.Session_properties_get)
Session_swigregister = _speech_py_impl.Session_swigregister
Session_swigregister(Session)

class Connection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Connection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Connection, name)
    __repr__ = _swig_repr
    if _newclass:
        from_recognizer = staticmethod(_speech_py_impl.Connection_from_recognizer)
    else:
        from_recognizer = _speech_py_impl.Connection_from_recognizer

    def open(self, forContinuousRecognition        )          :
        return _speech_py_impl.Connection_open(self, forContinuousRecognition)

    def close(self)          :
        return _speech_py_impl.Connection_close(self)
    __swig_getmethods__["connected"] = _speech_py_impl.Connection_connected_get
    if _newclass:
        connected = _swig_property(_speech_py_impl.Connection_connected_get)
    __swig_getmethods__["disconnected"] = _speech_py_impl.Connection_disconnected_get
    if _newclass:
        disconnected = _swig_property(_speech_py_impl.Connection_disconnected_get)

    def __init__(self, handle                       ):
        this = _speech_py_impl.new_Connection(handle)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _speech_py_impl.delete_Connection
    __del__ = lambda self: None
Connection_swigregister = _speech_py_impl.Connection_swigregister
Connection_swigregister(Connection)

def Connection_from_recognizer(recognizer                                                                       )                                                                         :
    return _speech_py_impl.Connection_from_recognizer(recognizer)
Connection_from_recognizer = _speech_py_impl.Connection_from_recognizer


from enum import Enum
def inject_enum(prefix     ):
# get swig-generated enum values
    swig_enum_vars = {k: v for k, v in globals().items() if k.startswith(prefix + '_')}
    for k, v in swig_enum_vars.items():
        del globals()[k]
    new_enum_vars = {k[len(prefix) + 1: ]: v for k, v in swig_enum_vars.items()}
# create python enum and inject into module namespace
    globals()[prefix] = Enum(prefix, new_enum_vars)

inject_enum('CancellationReason')
inject_enum('CancellationErrorCode')
inject_enum('NoMatchReason')
inject_enum('OutputFormat')
inject_enum('PropertyId')
inject_enum('ResultReason')

# clean up the exported names
del inject_enum
del Enum


swigregister_class_names = [variable_name for variable_name in globals() if variable_name.endswith('_swigregister')]
from_factory_method_names = [variable_name for variable_name in globals() if '__from' in variable_name.lower()]
for variable_name in swigregister_class_names + from_factory_method_names:
    del globals()[variable_name]

del from_factory_method_names, swigregister_class_names, variable_name

# This file is compatible with both classic and new-style classes.


